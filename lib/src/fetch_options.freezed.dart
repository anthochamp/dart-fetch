// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'fetch_options.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
mixin _$FetchOptions {
  String get method => throw _privateConstructorUsedError;
  Uri get url => throw _privateConstructorUsedError;
  HttpxHeaders? get headers => throw _privateConstructorUsedError;
  Iterable<HttpxCredentials>? get realmsCredentials =>
      throw _privateConstructorUsedError;
  Map<String, StructuredDataEncoder>? get structuredDataEncoders =>
      throw _privateConstructorUsedError;
  Map<String, StructuredDataDecoder>? get structuredDataDecoders =>
      throw _privateConstructorUsedError;
  TypedDataEncoder? get defaultTypedDataEncoder =>
      throw _privateConstructorUsedError;
  TypedDataDecoder? get defaultTypedDataDecoder =>
      throw _privateConstructorUsedError;
  int? get maxRedirects => throw _privateConstructorUsedError;
  HttpxCachePolicy? get cachePolicy => throw _privateConstructorUsedError;
  dynamic get metadata => throw _privateConstructorUsedError;
  Duration? get connectionTimeout => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $FetchOptionsCopyWith<FetchOptions> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $FetchOptionsCopyWith<$Res> {
  factory $FetchOptionsCopyWith(
          FetchOptions value, $Res Function(FetchOptions) then) =
      _$FetchOptionsCopyWithImpl<$Res, FetchOptions>;
  @useResult
  $Res call(
      {String method,
      Uri url,
      HttpxHeaders? headers,
      Iterable<HttpxCredentials>? realmsCredentials,
      Map<String, StructuredDataEncoder>? structuredDataEncoders,
      Map<String, StructuredDataDecoder>? structuredDataDecoders,
      TypedDataEncoder? defaultTypedDataEncoder,
      TypedDataDecoder? defaultTypedDataDecoder,
      int? maxRedirects,
      HttpxCachePolicy? cachePolicy,
      dynamic metadata,
      Duration? connectionTimeout});
}

/// @nodoc
class _$FetchOptionsCopyWithImpl<$Res, $Val extends FetchOptions>
    implements $FetchOptionsCopyWith<$Res> {
  _$FetchOptionsCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? method = null,
    Object? url = null,
    Object? headers = freezed,
    Object? realmsCredentials = freezed,
    Object? structuredDataEncoders = freezed,
    Object? structuredDataDecoders = freezed,
    Object? defaultTypedDataEncoder = freezed,
    Object? defaultTypedDataDecoder = freezed,
    Object? maxRedirects = freezed,
    Object? cachePolicy = freezed,
    Object? metadata = freezed,
    Object? connectionTimeout = freezed,
  }) {
    return _then(_value.copyWith(
      method: null == method
          ? _value.method
          : method // ignore: cast_nullable_to_non_nullable
              as String,
      url: null == url
          ? _value.url
          : url // ignore: cast_nullable_to_non_nullable
              as Uri,
      headers: freezed == headers
          ? _value.headers
          : headers // ignore: cast_nullable_to_non_nullable
              as HttpxHeaders?,
      realmsCredentials: freezed == realmsCredentials
          ? _value.realmsCredentials
          : realmsCredentials // ignore: cast_nullable_to_non_nullable
              as Iterable<HttpxCredentials>?,
      structuredDataEncoders: freezed == structuredDataEncoders
          ? _value.structuredDataEncoders
          : structuredDataEncoders // ignore: cast_nullable_to_non_nullable
              as Map<String, StructuredDataEncoder>?,
      structuredDataDecoders: freezed == structuredDataDecoders
          ? _value.structuredDataDecoders
          : structuredDataDecoders // ignore: cast_nullable_to_non_nullable
              as Map<String, StructuredDataDecoder>?,
      defaultTypedDataEncoder: freezed == defaultTypedDataEncoder
          ? _value.defaultTypedDataEncoder
          : defaultTypedDataEncoder // ignore: cast_nullable_to_non_nullable
              as TypedDataEncoder?,
      defaultTypedDataDecoder: freezed == defaultTypedDataDecoder
          ? _value.defaultTypedDataDecoder
          : defaultTypedDataDecoder // ignore: cast_nullable_to_non_nullable
              as TypedDataDecoder?,
      maxRedirects: freezed == maxRedirects
          ? _value.maxRedirects
          : maxRedirects // ignore: cast_nullable_to_non_nullable
              as int?,
      cachePolicy: freezed == cachePolicy
          ? _value.cachePolicy
          : cachePolicy // ignore: cast_nullable_to_non_nullable
              as HttpxCachePolicy?,
      metadata: freezed == metadata
          ? _value.metadata
          : metadata // ignore: cast_nullable_to_non_nullable
              as dynamic,
      connectionTimeout: freezed == connectionTimeout
          ? _value.connectionTimeout
          : connectionTimeout // ignore: cast_nullable_to_non_nullable
              as Duration?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_FetchOptionsCopyWith<$Res>
    implements $FetchOptionsCopyWith<$Res> {
  factory _$$_FetchOptionsCopyWith(
          _$_FetchOptions value, $Res Function(_$_FetchOptions) then) =
      __$$_FetchOptionsCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String method,
      Uri url,
      HttpxHeaders? headers,
      Iterable<HttpxCredentials>? realmsCredentials,
      Map<String, StructuredDataEncoder>? structuredDataEncoders,
      Map<String, StructuredDataDecoder>? structuredDataDecoders,
      TypedDataEncoder? defaultTypedDataEncoder,
      TypedDataDecoder? defaultTypedDataDecoder,
      int? maxRedirects,
      HttpxCachePolicy? cachePolicy,
      dynamic metadata,
      Duration? connectionTimeout});
}

/// @nodoc
class __$$_FetchOptionsCopyWithImpl<$Res>
    extends _$FetchOptionsCopyWithImpl<$Res, _$_FetchOptions>
    implements _$$_FetchOptionsCopyWith<$Res> {
  __$$_FetchOptionsCopyWithImpl(
      _$_FetchOptions _value, $Res Function(_$_FetchOptions) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? method = null,
    Object? url = null,
    Object? headers = freezed,
    Object? realmsCredentials = freezed,
    Object? structuredDataEncoders = freezed,
    Object? structuredDataDecoders = freezed,
    Object? defaultTypedDataEncoder = freezed,
    Object? defaultTypedDataDecoder = freezed,
    Object? maxRedirects = freezed,
    Object? cachePolicy = freezed,
    Object? metadata = freezed,
    Object? connectionTimeout = freezed,
  }) {
    return _then(_$_FetchOptions(
      method: null == method
          ? _value.method
          : method // ignore: cast_nullable_to_non_nullable
              as String,
      url: null == url
          ? _value.url
          : url // ignore: cast_nullable_to_non_nullable
              as Uri,
      headers: freezed == headers
          ? _value.headers
          : headers // ignore: cast_nullable_to_non_nullable
              as HttpxHeaders?,
      realmsCredentials: freezed == realmsCredentials
          ? _value.realmsCredentials
          : realmsCredentials // ignore: cast_nullable_to_non_nullable
              as Iterable<HttpxCredentials>?,
      structuredDataEncoders: freezed == structuredDataEncoders
          ? _value._structuredDataEncoders
          : structuredDataEncoders // ignore: cast_nullable_to_non_nullable
              as Map<String, StructuredDataEncoder>?,
      structuredDataDecoders: freezed == structuredDataDecoders
          ? _value._structuredDataDecoders
          : structuredDataDecoders // ignore: cast_nullable_to_non_nullable
              as Map<String, StructuredDataDecoder>?,
      defaultTypedDataEncoder: freezed == defaultTypedDataEncoder
          ? _value.defaultTypedDataEncoder
          : defaultTypedDataEncoder // ignore: cast_nullable_to_non_nullable
              as TypedDataEncoder?,
      defaultTypedDataDecoder: freezed == defaultTypedDataDecoder
          ? _value.defaultTypedDataDecoder
          : defaultTypedDataDecoder // ignore: cast_nullable_to_non_nullable
              as TypedDataDecoder?,
      maxRedirects: freezed == maxRedirects
          ? _value.maxRedirects
          : maxRedirects // ignore: cast_nullable_to_non_nullable
              as int?,
      cachePolicy: freezed == cachePolicy
          ? _value.cachePolicy
          : cachePolicy // ignore: cast_nullable_to_non_nullable
              as HttpxCachePolicy?,
      metadata: freezed == metadata
          ? _value.metadata
          : metadata // ignore: cast_nullable_to_non_nullable
              as dynamic,
      connectionTimeout: freezed == connectionTimeout
          ? _value.connectionTimeout
          : connectionTimeout // ignore: cast_nullable_to_non_nullable
              as Duration?,
    ));
  }
}

/// @nodoc

class _$_FetchOptions implements _FetchOptions {
  const _$_FetchOptions(
      {required this.method,
      required this.url,
      this.headers,
      this.realmsCredentials,
      final Map<String, StructuredDataEncoder>? structuredDataEncoders,
      final Map<String, StructuredDataDecoder>? structuredDataDecoders,
      this.defaultTypedDataEncoder,
      this.defaultTypedDataDecoder,
      this.maxRedirects,
      this.cachePolicy,
      this.metadata,
      this.connectionTimeout})
      : _structuredDataEncoders = structuredDataEncoders,
        _structuredDataDecoders = structuredDataDecoders;

  @override
  final String method;
  @override
  final Uri url;
  @override
  final HttpxHeaders? headers;
  @override
  final Iterable<HttpxCredentials>? realmsCredentials;
  final Map<String, StructuredDataEncoder>? _structuredDataEncoders;
  @override
  Map<String, StructuredDataEncoder>? get structuredDataEncoders {
    final value = _structuredDataEncoders;
    if (value == null) return null;
    if (_structuredDataEncoders is EqualUnmodifiableMapView)
      return _structuredDataEncoders;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(value);
  }

  final Map<String, StructuredDataDecoder>? _structuredDataDecoders;
  @override
  Map<String, StructuredDataDecoder>? get structuredDataDecoders {
    final value = _structuredDataDecoders;
    if (value == null) return null;
    if (_structuredDataDecoders is EqualUnmodifiableMapView)
      return _structuredDataDecoders;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(value);
  }

  @override
  final TypedDataEncoder? defaultTypedDataEncoder;
  @override
  final TypedDataDecoder? defaultTypedDataDecoder;
  @override
  final int? maxRedirects;
  @override
  final HttpxCachePolicy? cachePolicy;
  @override
  final dynamic metadata;
  @override
  final Duration? connectionTimeout;

  @override
  String toString() {
    return 'FetchOptions(method: $method, url: $url, headers: $headers, realmsCredentials: $realmsCredentials, structuredDataEncoders: $structuredDataEncoders, structuredDataDecoders: $structuredDataDecoders, defaultTypedDataEncoder: $defaultTypedDataEncoder, defaultTypedDataDecoder: $defaultTypedDataDecoder, maxRedirects: $maxRedirects, cachePolicy: $cachePolicy, metadata: $metadata, connectionTimeout: $connectionTimeout)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_FetchOptions &&
            (identical(other.method, method) || other.method == method) &&
            (identical(other.url, url) || other.url == url) &&
            (identical(other.headers, headers) || other.headers == headers) &&
            const DeepCollectionEquality()
                .equals(other.realmsCredentials, realmsCredentials) &&
            const DeepCollectionEquality().equals(
                other._structuredDataEncoders, _structuredDataEncoders) &&
            const DeepCollectionEquality().equals(
                other._structuredDataDecoders, _structuredDataDecoders) &&
            (identical(
                    other.defaultTypedDataEncoder, defaultTypedDataEncoder) ||
                other.defaultTypedDataEncoder == defaultTypedDataEncoder) &&
            (identical(
                    other.defaultTypedDataDecoder, defaultTypedDataDecoder) ||
                other.defaultTypedDataDecoder == defaultTypedDataDecoder) &&
            (identical(other.maxRedirects, maxRedirects) ||
                other.maxRedirects == maxRedirects) &&
            (identical(other.cachePolicy, cachePolicy) ||
                other.cachePolicy == cachePolicy) &&
            const DeepCollectionEquality().equals(other.metadata, metadata) &&
            (identical(other.connectionTimeout, connectionTimeout) ||
                other.connectionTimeout == connectionTimeout));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      method,
      url,
      headers,
      const DeepCollectionEquality().hash(realmsCredentials),
      const DeepCollectionEquality().hash(_structuredDataEncoders),
      const DeepCollectionEquality().hash(_structuredDataDecoders),
      defaultTypedDataEncoder,
      defaultTypedDataDecoder,
      maxRedirects,
      cachePolicy,
      const DeepCollectionEquality().hash(metadata),
      connectionTimeout);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_FetchOptionsCopyWith<_$_FetchOptions> get copyWith =>
      __$$_FetchOptionsCopyWithImpl<_$_FetchOptions>(this, _$identity);
}

abstract class _FetchOptions implements FetchOptions {
  const factory _FetchOptions(
      {required final String method,
      required final Uri url,
      final HttpxHeaders? headers,
      final Iterable<HttpxCredentials>? realmsCredentials,
      final Map<String, StructuredDataEncoder>? structuredDataEncoders,
      final Map<String, StructuredDataDecoder>? structuredDataDecoders,
      final TypedDataEncoder? defaultTypedDataEncoder,
      final TypedDataDecoder? defaultTypedDataDecoder,
      final int? maxRedirects,
      final HttpxCachePolicy? cachePolicy,
      final dynamic metadata,
      final Duration? connectionTimeout}) = _$_FetchOptions;

  @override
  String get method;
  @override
  Uri get url;
  @override
  HttpxHeaders? get headers;
  @override
  Iterable<HttpxCredentials>? get realmsCredentials;
  @override
  Map<String, StructuredDataEncoder>? get structuredDataEncoders;
  @override
  Map<String, StructuredDataDecoder>? get structuredDataDecoders;
  @override
  TypedDataEncoder? get defaultTypedDataEncoder;
  @override
  TypedDataDecoder? get defaultTypedDataDecoder;
  @override
  int? get maxRedirects;
  @override
  HttpxCachePolicy? get cachePolicy;
  @override
  dynamic get metadata;
  @override
  Duration? get connectionTimeout;
  @override
  @JsonKey(ignore: true)
  _$$_FetchOptionsCopyWith<_$_FetchOptions> get copyWith =>
      throw _privateConstructorUsedError;
}
